<!-- ## Intention -->
<h2>
	<img src="/icons/history-solid.svg?style=fill:grey;" alt="Intention" rel="prefetch" />
	Intention
	<a class="hide" href="/icons/history-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

The intention of our offering was as follows.
I (Brian) would be offering development & documentation services.
I was to be the subject of the position that we have been discussing.
For this project, **Tracy was to assist me** in client communication, attending meetings,
	design & systems ideas/feedback, writing, etc.
She has been immensely helpful for several projects & it's highly beneficial to continue investing in
	this collaboration.

A negotiation on rates took place, resulting in a **price point well below industry average** for a
	full stack developer who can create a scalable system of components, practices, documentation,
	cloud-based interactive development environment, & starter apps using the Holochain application stack.
Tracy is to be an addition to our offering, rather than the focus.

<!-- ## Domain Language & Patterns -->
<h2>
	<img src="/icons/language-solid.svg?style=fill:grey;" alt="Domain Language & Patterns" rel="prefetch" />
	Domain Language & Patterns
	<a class="hide" href="/icons/language-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>	

I face some similar challenges to Holochain.
How to communicate a framework of tools, both of abstract forms & tangible software,
	to the public of various technical context & telos.
I have been developing software practices based on a
	<a target="_blank" href="https://github.com/btakita/philosophy">Meta Philosophy</a> centered around:

* a scalable domain language
* patterns of definition
* globally unique names
* flat data structures
* functional reactive data flow

An explicit global domain language applied to business literature & code,
	results in a reduction of software & abstraction mapping needed to encapsulate ambiguous naming.
I have a couple of blog posts describing naming convention that adheres to the global domain language principle,
	that I have tested across a few organizations ranging in complexity.

* <a target="_blank" href="http://www.briantakita.com/posts/naming-conventions/">Naming Conventions</a>
* <a target="_blank" href="http://www.briantakita.com/posts/multi-underscore-tag-naming-convention-analysis/">
		Multi Underscore Tag Naming Convention Analysis
	</a>

<!-- ## Code -->
<h2>
	<img src="/icons/code-solid.svg?style=fill:grey;" alt="Code" rel="prefetch" />
	Code
	<a class="hide" href="/icons/code-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>	

I have created the <a target="_blank" href="https://github.com/ctx-core/ctx-core">ctx-core</a> library,
	which is a composable monorepo used in several of my projects.
Currently, the ctx-core monorepo manages 130 packages, which are opportunistically extracted.
A key for reuse is to primarily use functions & Higher Order Functions to transform data.
This is opposed to Object Oriented programming, tightly coupling data with functions,
	creates incidental complexity & reduces reuse potential.

During this development, I have formed techniques to develop & reuse:

* application code
* library code
* web services
* web components
* project-specific development environments
* command line tools

My applicable experience lies crafting solutions that scale with complexity, interactivity, & reuse potential
	across the organization's domain.
While this practice is relatively young, I have obtained knowhow in creating a complex ecosystem of reusable
	apps, components, & services which can be reused as a catalog of starter projects varying in domain specificity.

### Simple is the foundation of Complex

An emerging principle is effective simple applications form the perennial foundation
	to effective complex applications.
In praxis, maintaining simple apps concurrently with complex apps leads to an effective architecture tested
	with various levels of scale.
Testing with scale forms evidence of the universality of concepts, which can be applied to open system,
	such as tech, markets, social dynamics, etc.

<!-- ## Core Libraries -->
<h2>
	<img src="/icons/sitemap-solid.svg?style=fill:grey;" alt="Core Libraries"/>
	Core Libraries
	<a class="hide" href="/icons/sitemap-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

My core libraries serve as the best indicator of example of my ability to architect composable systems that have:

* no runtime framework dependencies
* small payload
* low memory usage
* performant
* forking & multi-tenant capabilities built into the process

<!-- ## Technical Alignment -->
<h2>
	<img src="/icons/sync-solid.svg?style=fill:grey;" alt="Technical Alignment"/>
	Technical Alignment
	<a class="hide" href="/icons/sync-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

I also have a General Systems Theory model to my practice.
General Systems Theory finds patterns across all systems & much headway is gained when considering
 Open Systems, which includes biology (biomimicry), culture, & software development.

<!-- ## A Quick & Rough Example of Development Process -->
<h2>
	<img src="/icons/laptop-code-solid.svg?style=fill:grey;" alt="A Quick & Rough Example of Development Process"/>
	A Quick & Rough Example of Development Process
	<a class="hide" href="/icons/laptop-code-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

I am grateful for our investigation.
This situation has inspired some tech & will also lead to a more public portfolio of what I have to share.
My challenge is that I'm bringing forth novel concepts & it's a challenge to articulate these concepts to
	an audience coming from different contexts.
One thing that makes me excited about Holochain is the alignment to natural processes.
You asked for examples & I think demonstrating a process example best exemplifies the added value we can bring.

I created a repository for
	<a target="_blank" href="https://github.com/btakita/business">public business</a> matters.
This project was forked from progress made with the
	<a target="_blank" href="https://github.com/btakita/holochain-developer-prototype">holochain-developer-prototype</a>
	repo.
	
I have since created a
	<a target="_blank" href="https://github.com/ctx-core/sapper-template/tree/ctx-core">template project</a>,
	which itself is forked from the
	<a target="_blank" href="https://github.com/sveltejs/sapper-template/tree/rollup">sapper template</a>.

I also extracted common code into ctx-core libraries (
	<a target="_blank" href="https://github.com/ctx-core/ctx-core/tree/master/packages/highlight.js">
		@ctx-core/highlight.js
	</a> &
	<a target="_blank" href="https://github.com/ctx-core/ctx-core/tree/master/packages/markdown">
		@ctx-core/markdown
	</a>).
I engaged in a process of concurrent development between the three repositories (2 apps & 2 libraries in ctx-core).
I also used
	<a target="_blank" href="https://lerna.js.org/">lerna.js</a> to manage the monorepo,
	<a target="_blank" href="https://direnv.net/">direnv</a>,
	& custom scripts.
This is a use case of developing multiple apps & libraries concurrently, which I'm happy to provide a
	free code review with anybody on your team who is interested.
This is a work in progress & I'm looking for collaboration & investment,
	preferably with clients who are aligned with the technical vision.
	
<!-- ## Custom Software -->
<h2>
	<img src="/icons/cogs-solid.svg?style=fill:grey;" alt="Custom Software" rel="prefetch" />
	Custom Software
	<a class="hide" href="/icons/cogs-solid.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

The advantage to using custom software, coupled with a framework that enables rapid iteration,
	is that you can create a tailor-made documentation, development, & reading experience.
	
<!-- ## Potentialities -->
<h2>
	<img src="/icons/lightbulb-regular.svg?style=fill:grey;" alt="Potentialities" rel="prefetch" />
	Potentialities
	<a class="hide" href="/icons/lightbulb-regular.svg?style=fill:grey;" rel="prefetch"></a>
</h2>

There are many potential avenues of innovation, connectedness, neural growth.
For example, if a global naming convention is adhered to,
	Natural Language Processing & code parse trees can also be utilized to
	analyze & link code in the Holochain Core, libraries, & application ecosystem
	with curated content (documentation, newsletters, blogs),
	creating a graph of related entities with a UI to navigate the graph.

Regardless of the outcome, I have created a systematic way of development
	where my practice is always moving forward.
A Meta-Philosophy-backed domain language methodology ensures framework development
	that scales with complexity across a multitude of
	organizations, applications, libraries, platforms, 3rd party apis
	while facilitating precise movement of abstraction to the appropriate library.

Sincerely, \
Brian Takita

<style>
	.prefetch {
		display: none;
	}
	h2 img {
		width: 1rem;
		height: 1rem;
	}
</style>
